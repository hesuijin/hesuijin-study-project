#### 线程状态 

##### 1：线程状态有多少种？
    1. NEW(新建) 线程刚被创建，但是并未启动。还没调用start方法。 
    2. Runnable(可 运行) 线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操 作系统处理器。 
    3. Blocked(锁阻 塞) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状 态；当该线程持有锁时，该线程将变成Runnable状态。
    4. Waiting(无限 等待) 一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个 状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。
    5. Timed Waiting(计时 等待) 同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态 将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、 Object.wait。 
    6. Teminated(被 终止) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。
   
##### 2：最常见的等待唤醒机制是哪一种模式？
    
    使用 Object 中的 wait() 方法让线程等待，使用 Object 中的 notify() 方法唤醒线

##### 3：死锁
    线程死锁是指由于两个或者多个线程互相持有对方所需要的资源，导致这些线程处于等待状态，无法前往执行
  
##### 4：消费生产者模式 其中的关键点是，
    1.生产是一个一直执行的线程，消费是一个一直执行的线程    
    2.而他们使用共同的一把锁（只能同时进行一个线程）
    3.每次需要消费线程执行逻辑的时候，必须先等待生产线程的唤醒
    4.每次需要生产线程执行逻辑的时候，必须先等待消费线程的唤醒
  
     消费者步骤：
     进入循环
     1：获取对象锁
     2：判断桌子上是否有包子。
     3：如果没有 
            对象锁等待 等待唤醒   该线程的逻辑一直等待  然后对象锁可以被其他地方获取 
     4：如果有
            包子数减少减1个 当包子数为0时 叫醒等待的生产者继续生产  
               
     生产者步骤：
     进入循环
     1：获取对象锁
     2：判断桌子上是否有包子。
     3：如果有 
        对象锁等待 等待唤醒  该线程的逻辑一直等待  然后对象锁可以被其他地方获取 
     4：如果没有
              包子数加10个 叫醒等待的消费者继续吃               
  
#####  可阅读stateThreadDemo包下代码    